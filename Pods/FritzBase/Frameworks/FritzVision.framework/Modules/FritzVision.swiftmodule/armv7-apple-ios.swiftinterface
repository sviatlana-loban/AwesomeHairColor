// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1.2 (swiftlang-1100.0.278 clang-1100.0.33.9)
// swift-module-flags: -target armv7-apple-ios9.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name FritzVision
import AVFoundation
import Accelerate
import CoreGraphics
import CoreImage
import CoreML
import Foundation
import FritzManagedModel
@_exported import FritzVision
import Photos
import Swift
import UIKit
import Vision
@available(iOS 11.0, *)
public protocol FritzPredictable : FritzVision.FritzManagedModelType {
  associatedtype PredictionInput : FritzVision.FritzPredictionInput
  associatedtype ModelOptions : FritzVision.FritzPredictorOptionType
  associatedtype PredictionResult : FritzVision.FritzPredictionResult
  func predict(_ input: Self.PredictionInput, options: Self.ModelOptions, completion: (Self.PredictionResult?, Swift.Error?) -> Swift.Void)
  func predict(_ input: Self.PredictionInput, options: Self.ModelOptions) throws -> Self.PredictionResult
}
@available(iOS 11.0, *)
extension FritzPredictable {
  public func predict(_ input: Self.PredictionInput, options: Self.ModelOptions = .init()) throws -> Self.PredictionResult
}
@available(iOS 11.0, *)
public protocol FritzVisionImagePredictable : FritzVision.FritzPredictable where Self.ModelOptions : FritzVision.FritzImageOptions, Self.PredictionInput : FritzVision.FritzVisionImage {
  func predict(_ input: Self.PredictionInput, options: Self.ModelOptions, completion: (Self.PredictionResult?, Swift.Error?) -> Swift.Void)
}
@available(iOS 12.0, *)
@objc(FritzVisionPeopleSegmentationModelSmall) final public class FritzVisionPeopleSegmentationModelSmall : FritzVision.FritzVisionPeopleSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionPeopleSegmentationModelSmall?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionImageMetadata) public class FritzVisionImageMetadata : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public var orientation: FritzVision.FritzImageOrientation
  @objc public var cgOrientation: ImageIO.CGImagePropertyOrientation {
    @objc get
  }
  @objc deinit
}
@available(iOS 11.0, *)
public class ObjectDetectionInputProvider : CoreML.MLFeatureProvider {
  @objc public var featureNames: Swift.Set<Swift.String> {
    @objc get
  }
  @objc public func featureValue(for featureName: Swift.String) -> CoreML.MLFeatureValue?
  public init(image: CoreVideo.CVPixelBuffer? = nil, iouThreshold: Swift.Double? = nil, confidenceThreshold: Swift.Double? = nil)
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionLivingRoomSegmentationModelFast) final public class FritzVisionLivingRoomSegmentationModelFast : FritzVision.FritzVisionLivingRoomSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionLivingRoomSegmentationModelFast?, Swift.Error?) -> Swift.Void)
  @objc required public init(model: FritzManagedModel.FritzMLModel)
  @objc required public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc required public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc deinit
}
extension CVBuffer {
  public func normalize()
  public func pixelValues() -> [Swift.Float]
  public func printDebugInfo()
}
public protocol PointType {
  func toArray() -> [Swift.Double]
  static func - (lhs: Self, rhs: Self) -> Self
  static func / (lhs: Self, rhs: Self) -> Self
  static func / (lhs: Self, rhs: Swift.Double) -> Self
  static func * (lhs: Self, rhs: Self) -> Self
}
@available(iOS 11.0, *)
public protocol PackagedModelType {
  init()
}
final public class Keypoint3D<Skeleton> : ObjectiveC.NSObject, FritzVision.KeypointType where Skeleton : FritzVision.SkeletonType {
  final public let index: Swift.Int
  final public let position: FritzVision.Point3D
  final public let score: Swift.Double
  final public let part: Skeleton
  public init(index: Swift.Int, position: FritzVision.Point3D, score: Swift.Double, part: Skeleton)
  @objc override final public var description: Swift.String {
    @objc get
  }
  final public func fromPosition(_ position: FritzVision.Point3D) -> FritzVision.Keypoint3D<Skeleton>
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
  public typealias Point = FritzVision.Point3D
}
public func == <Skeleton>(lhs: FritzVision.Keypoint3D<Skeleton>, rhs: FritzVision.Keypoint3D<Skeleton>) -> Swift.Bool where Skeleton : FritzVision.SkeletonType
public class SmoothingPoint {
  public var xAccel: Swift.Double
  public var yAccel: Swift.Double
  public var zAccel: Swift.Double
  public init(dataX: Swift.Double, dataY: Swift.Double, dataZ: Swift.Double, count: Swift.Int)
  public init()
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionLabelModelFast) final public class FritzVisionLabelModelFast : FritzVision.FritzVisionLabelPredictor, FritzVision.DownloadableModel {
  @objc public static var modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionLabelModelFast?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc deinit
}
@available(iOS 11.0, *)
public protocol FritzManagedModelType {
  var managedModel: FritzManagedModel.FritzManagedModel { get }
  var metadata: [Swift.String : Swift.String]? { get }
  var tags: [Swift.String]? { get }
}
public enum FritzVisionModelTagError : Swift.Error {
  case loadingModelsFailed(errors: [Swift.Error])
  case noModelReturned
}
@available(iOS 11.0, *)
@objc public enum FritzImageOrientation : Swift.Int32 {
  case up = 1
  case upMirrored
  case down
  case downMirrored
  case leftMirrored
  case right
  case rightMirrored
  case left
  public typealias RawValue = Swift.Int32
  public init?(rawValue: Swift.Int32)
  public var rawValue: Swift.Int32 {
    get
  }
}
@available(iOS 11.0, *)
extension FritzImageOrientation {
  public init(_ uiOrientation: UIKit.UIImage.Orientation)
  public init(from connection: AVFoundation.AVCaptureConnection)
  public static func fromAVCaptureConnection(from connection: AVFoundation.AVCaptureConnection) -> FritzVision.FritzImageOrientation
}
@available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
@objc(FritzVisionSegmentationResult) public class FritzVisionSegmentationResult : ObjectiveC.NSObject, FritzVision.FritzPredictionResult {
  @objc final public let height: Swift.Int
  @objc final public let width: Swift.Int
  @objc final public let classes: [FritzVision.ModelSegmentationClass]
  @objc final public let predictionResult: CoreML.MLMultiArray
  public func getArrayOfMostLikelyClasses(withMinimumConfidenceScore minimumConfidence: Swift.Double = 0.0) -> [Swift.Int32]
  @objc override dynamic public init()
  @objc deinit
}
public typealias ConnectedPart<Skeleton> = (Skeleton, Skeleton) where Skeleton : FritzVision.SkeletonType
public protocol SkeletonType : Swift.CaseIterable, Swift.Equatable, Swift.RawRepresentable {
  init?(rawValue: Swift.Int)
  var rawValue: Swift.Int { get }
  static var connectedParts: [FritzVision.ConnectedPart<Self>] { get }
  static var poseChain: [FritzVision.ConnectedPart<Self>] { get }
}
extension SkeletonType {
  public static var numParts: Swift.Int {
    get
  }
  public static var connectedParts: [FritzVision.ConnectedPart<Self>] {
    get
  }
  public static var poseChain: [FritzVision.ConnectedPart<Self>] {
    get
  }
  public static var parentChildTuples: [FritzVision.ConnectedPart<Self>] {
    get
  }
  public static var parentToChildEdges: [Self] {
    get
  }
  public static var childToParentEdges: [Self] {
    get
  }
  public static func getConnectedKeypoints<Skeleton>(keypoints: [FritzVision.Keypoint<Skeleton>], minConfidence: Swift.Double) -> [(left: FritzVision.Keypoint<Skeleton>, right: FritzVision.Keypoint<Skeleton>)] where Skeleton : FritzVision.SkeletonType
}
extension UIImage {
  public static func masked(_ source: UIKit.UIImage, withAlphaMask mask: UIKit.UIImage, using context: CoreImage.CIContext) -> UIKit.UIImage?
}
@available(iOS 11.0, *)
extension CIImagePipeline {
  @objc dynamic public func mask(with alphaMask: UIKit.UIImage, removing segmentationRegion: FritzVision.SegmentationRegion = .background)
}
@objc(FritzSegmentationRegion) public enum SegmentationRegion : Swift.Int {
  case foreground
  case background
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOS 11.0, *)
extension FritzVisionImage {
  @objc(maskWithImage:removingPixelsIn:samplingMethod:context:) dynamic public func masked(with alphaMask: UIKit.UIImage, removing segmentationRegion: FritzVision.SegmentationRegion = .background, resizeSamplingMethod samplingMethod: FritzVision.CIImagePipeline.ResizeSamplingMethod = .lanczos, using context: CoreImage.CIContext? = nil) -> UIKit.UIImage?
}
public class ObjectModelSpec {
  public struct AnchorBoxModelDef {
  }
  public struct BoundingBoxModelDef {
  }
  @objc deinit
}
public protocol ArrayInitializable : FritzVision.PointType {
  init(with array: [CoreGraphics.CGFloat])
}
extension Point3D : FritzVision.ArrayInitializable {
  @objc convenience dynamic public init(with array: [CoreGraphics.CGFloat])
}
@available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
@objc(FritzVisionLabel) public class FritzVisionLabel : ObjectiveC.NSObject, FritzVision.FritzPredictionResult {
  @objc final public let label: Swift.String
  @objc final public let confidence: Swift.Double
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc(initWithLabel:confidence:) public init(label: Swift.String, confidence: Swift.Double)
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
public class FritzVisionBlendHairCompoundFilter : FritzVision.FritzVisionSegmentationFilter {
  final public let compositionMode: FritzVision.FilterCompositionMode
  final public let model: FritzVision.FritzVisionSegmentationModel
  final public let options: FritzVision.FritzVisionSegmentationMaskOptions
  public init(model: FritzVision.FritzVisionHairSegmentationPredictor, options: FritzVision.FritzVisionSegmentationMaskOptions = .init())
  public func process(_ image: FritzVision.FritzVisionImage) -> FritzVision.FritzVisionBlendHairCompoundFilter.FritzVisionFilterResult
  @objc deinit
}
@available(*, deprecated, renamed: "FlexibleModelDimensions")
@objc(StyleOutputDimensions) public class StyleOutputDimensions : FritzVision.FlexibleModelDimensions {
  @objc override dynamic public init()
  @objc override public init(size: CoreGraphics.CGSize)
  @objc override public init(width: Swift.Int, height: Swift.Int)
  @objc deinit
}
@objc(FlexibleModelDimensions) public class FlexibleModelDimensions : ObjectiveC.NSObject {
  final public let size: CoreGraphics.CGSize?
  @objc(init) override dynamic public init()
  @objc(initWithSize:) public init(size: CoreGraphics.CGSize)
  @objc(initWithWidth:withHeight:) public init(width: Swift.Int, height: Swift.Int)
  @objc deinit
}
extension FlexibleModelDimensions {
  @objc public static let original: FritzVision.FlexibleModelDimensions
  @objc public static let lowResolution: FritzVision.FlexibleModelDimensions
  @objc public static let mediumResolution: FritzVision.FlexibleModelDimensions
  @objc public static let highResolution: FritzVision.FlexibleModelDimensions
}
@objc(FritzVisionStyleModelOptions) final public class FritzVisionStyleModelOptions : ObjectiveC.NSObject, FritzVision.FritzImageOptions {
  @objc final public var imageCropAndScaleOption: FritzVision.FritzVisionCropAndScale
  @objc final public var forceCoreMLPrediction: Swift.Bool
  @objc final public var forceVisionPrediction: Swift.Bool
  @objc final public var resizeOutputToInputDimensions: Swift.Bool
  @objc final public var flexibleModelDimensions: FritzVision.FlexibleModelDimensions
  public static var defaults: FritzVision.FritzImageOptions
  @objc override dynamic public init()
  @objc deinit
}
@objc @available(iOS 12.0, *)
@available(*, deprecated, renamed: "FritzVisionStylePredictor")
public class FritzVisionFlexibleStyleModel : FritzVision.FritzVisionStylePredictor {
  @objc required public init(model: FritzManagedModel.FritzMLModel) throws
  @objc required public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel) throws
  @objc deinit
}
@objc @available(iOS 11.0, *)
@available(*, deprecated, renamed: "FritzVisionStylePredictor")
public class FritzVisionStyleModel : FritzVision.FritzVisionStylePredictor {
  @objc required public init(model: FritzManagedModel.FritzMLModel) throws
  @objc required public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel) throws
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionStylePredictor) public class FritzVisionStylePredictor : ObjectiveC.NSObject, FritzVision.FritzMLModelInitializable {
  public typealias PredictionInput = FritzVision.FritzVisionImage
  public typealias ModelOptions = FritzVision.FritzVisionStyleModelOptions
  public typealias PredictionResult = CoreVideo.CVPixelBuffer
  @objc final public let managedModel: FritzManagedModel.FritzManagedModel
  @objc(initWithIdentifiedModel:) convenience required public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc(initWithFritzMLModel:error:) required public init(model: FritzManagedModel.FritzMLModel) throws
  @objc(initWithFritzMLModel:managedModel:error:) required public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel) throws
  @objc(predict:options:completion:) public func predict(_ input: FritzVision.FritzVisionImage, options: FritzVision.FritzVisionStyleModelOptions = .init(), completion: (CoreVideo.CVPixelBuffer?, Swift.Error?) -> Swift.Void)
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
extension FritzVisionStylePredictor {
  @objc dynamic public var metadata: FritzManagedModel.ModelMetadata? {
    @objc get
  }
  @objc dynamic public var tags: [Swift.String]? {
    @objc get
  }
}
@available(iOS 11.0, *)
extension FritzVisionStylePredictor {
  @objc(fetchStyleModelsForTags:wifiRequiredForModelDownload:withCompletionHandler:) public static func fetchStyleModelsForTags(tags: [Swift.String], wifiRequiredForModelDownload: Swift.Bool = false, completionHandler: @escaping ([FritzVision.FritzVisionStylePredictor]?, Swift.Error?) -> Swift.Void)
}
@available(iOS 11.0, *)
public class FritzVisionMaskHairOverlayFilter : FritzVision.FritzVisionSegmentationFilter {
  final public let compositionMode: FritzVision.FilterCompositionMode
  final public let model: FritzVision.FritzVisionSegmentationModel
  final public let options: FritzVision.FritzVisionSegmentationMaskOptions
  public init(model: FritzVision.FritzVisionHairSegmentationPredictor, options: FritzVision.FritzVisionSegmentationMaskOptions = .init())
  public func process(_ image: FritzVision.FritzVisionImage) -> FritzVision.FritzVisionMaskHairOverlayFilter.FritzVisionFilterResult
  @objc deinit
}
@available(iOS 11.0, *)
public class MultiPoseSmoother<Filter, Skeleton> where Filter : FritzVision.PointFilterable, Skeleton : FritzVision.SkeletonType, Filter.T == CoreGraphics.CGPoint {
  public init(numKeypoints: Swift.Int, options: Filter.SmoothingOptionsType)
  public func smoothe(_ poses: [FritzVision.Pose<Skeleton>]) -> [FritzVision.Pose<Skeleton>]
  @objc deinit
}
@available(iOS 11.0, *)
public typealias IdentifiedPose<Skeleton> = (pose: FritzVision.Pose<Skeleton>, id: Swift.Int, lastIdentifiedAt: Foundation.Date) where Skeleton : FritzVision.SkeletonType
@available(iOS 11.0, *)
public class MultiPoseMatcher<Skeleton> where Skeleton : FritzVision.SkeletonType {
  public var identifiedPoses: [Swift.Int : FritzVision.IdentifiedPose<Skeleton>] {
    get
    }
  public var poses: [FritzVision.Pose<Skeleton>] {
    get
  }
  final public let iouThreshold: Swift.Float
  final public let lookback: Foundation.TimeInterval
  public init(iouThreshold: Swift.Float, lookback: Foundation.TimeInterval = 2.0)
  public var poseCount: Swift.Int {
    get
    }
  public func match(poses: [FritzVision.Pose<Skeleton>]) -> [FritzVision.IdentifiedPose<Skeleton>?]
  public func update(with newPoses: [FritzVision.Pose<Skeleton>], having matches: [FritzVision.IdentifiedPose<Skeleton>?]? = nil) -> [FritzVision.IdentifiedPose<Skeleton>]
  @objc deinit
}
@objc(BoundingBoxOutline) public class BoundingBoxOutline : ObjectiveC.NSObject {
  public init(fontSize: CoreGraphics.CGFloat = 14.0)
  @objc(parent:) public func addToLayer(_ parent: QuartzCore.CALayer)
  @objc(frame:label:color:textColor:) public func show(frame: CoreGraphics.CGRect, label: Swift.String, color: UIKit.UIColor, textColor: UIKit.UIColor = .black)
  @objc public func hide()
  @objc override dynamic public init()
  @objc deinit
}
precedencegroup PowerPrecedence {
  higherThan: MultiplicationPrecedence
}
infix operator ^^ : PowerPrecedence
public class SavitzkyGolayFilter<PointT> : FritzVision.PointFilterable where PointT : FritzVision.SmoothingPointable {
  public class Options : FritzVision.FilterOptions {
    public init(leftScan: Swift.Int = 2, rightScan: Swift.Int = 2, polonomialOrder: Swift.Int = 2)
    required public init()
    @objc deinit
  }
  required public init(options: FritzVision.SavitzkyGolayFilter<PointT>.Options)
  public func setParameter(name: Swift.String, value: Swift.Double)
  public func filter(_ point: PointT) -> PointT
  public func applyFilter(pointToProcess: FritzVision.SmoothingPoint, buffer: [FritzVision.SmoothingPoint]) -> FritzVision.SmoothingPoint
  public func shift(index: Swift.Int, input: [Swift.Double]) -> [Swift.Double]
  @objc deinit
  public typealias T = PointT
  public typealias SmoothingOptionsType = FritzVision.SavitzkyGolayFilter<PointT>.Options
}
@available(iOS 11.0, *)
public class Pose<Skeleton> : ObjectiveC.NSObject where Skeleton : FritzVision.SkeletonType {
  public static func == (lhs: FritzVision.Pose<Skeleton>, rhs: FritzVision.Pose<Skeleton>) -> Swift.Bool
  final public let keypoints: [FritzVision.Keypoint<Skeleton>]
  final public let score: Swift.Double
  final public let bounds: CoreGraphics.CGSize
  required public init(keypoints: [FritzVision.Keypoint<Skeleton>], score: Swift.Double, bounds: CoreGraphics.CGSize)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  public var boundingRect: CoreGraphics.CGRect {
    get
  }
  public func scaled(to targetDimensions: CoreGraphics.CGSize) -> FritzVision.Pose<Skeleton>
  public func getKeypoint(for part: Skeleton) -> FritzVision.Keypoint<Skeleton>?
  public func to3D() -> FritzVision.Pose3D<Skeleton>
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionPetSegmentationModelFast) final public class FritzVisionPetSegmentationModelFast : FritzVision.FritzVisionPetSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionPetSegmentationModelFast?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionHumanPosePredictor) @_objcRuntimeName(FritzVisionHumanPosePredictor) public class FritzVisionHumanPosePredictor : FritzVision.FritzVisionPosePredictor<FritzVision.HumanSkeleton> {
  @objc override public init(model: FritzManagedModel.FritzMLModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc deinit
}
public protocol KeypointType : AnyObject, Swift.Equatable {
  associatedtype Point : FritzVision.PointType
  associatedtype Skeleton : FritzVision.SkeletonType
  var index: Swift.Int { get }
  var position: Self.Point { get }
  var score: Swift.Double { get }
  init(index: Swift.Int, position: Self.Point, score: Swift.Double, part: Self.Skeleton)
  func fromPosition(_ position: Self.Point) -> Self
}
@available(iOS 11.0, *)
extension FritzVisionImage {
  public func draw<Skeleton>(poses: [FritzVision.Pose<Skeleton>], keypointsMeeting partThreshold: Swift.Double = 0.4, drawBoundingBox: Swift.Bool = false, drawSkeleton: Swift.Bool = true, lineWidth: CoreGraphics.CGFloat = 3.0) -> UIKit.UIImage? where Skeleton : FritzVision.SkeletonType
  public func draw<Skeleton>(pose: FritzVision.Pose<Skeleton>, keypointsMeeting partThreshold: Swift.Double = 0.4, drawBoundingBox: Swift.Bool = false, drawSkeleton: Swift.Bool = true, lineWidth: CoreGraphics.CGFloat = 3.0) -> UIKit.UIImage? where Skeleton : FritzVision.SkeletonType
}
@available(iOS 12.0, *)
@objc(FritzVisionHumanPoseModelSmall) @_objcRuntimeName(FritzVisionHumanPoseModelSmall) final public class FritzVisionHumanPoseModelSmall : FritzVision.FritzVisionHumanPosePredictor, FritzVision.DownloadableModel {
  @objc public static var modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionHumanPoseModelSmall?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionPoseModelAccurate) @_objcRuntimeName(FritzVisionPoseModelAccurate) final public class FritzVisionHumanPoseModelAccurate : FritzVision.FritzVisionHumanPosePredictor, FritzVision.DownloadableModel {
  @objc public static var modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionHumanPoseModelAccurate?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc deinit
}
public struct HeatmapPoint {
}
@available(iOS 11.0, *)
public class Displacements {
  public init(for results: CoreML.MLMultiArray?)
  public subscript(point: FritzVision.HeatmapPoint, edgeID: Swift.Int, offset: FritzVision.OffsetType) -> Swift.Double {
    get
  }
  public func sum() -> Swift.Double
  @objc deinit
}
@available(iOS 11.0, *)
public class HeatmapScores {
  public init(for results: CoreML.MLMultiArray?)
  public subscript(point: FritzVision.HeatmapPoint, partID: Swift.Int) -> Swift.Double {
    get
  }
  public subscript(y: Swift.Int, x: Swift.Int, keypointID: Swift.Int) -> Swift.Double {
    get
  }
  public func sum() -> Swift.Double
  @objc deinit
}
public enum OffsetType {
  case x
  case y
  public static func == (a: FritzVision.OffsetType, b: FritzVision.OffsetType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@available(iOS 11.0, *)
public class Offsets {
  public init(for results: CoreML.MLMultiArray?)
  public func get(y: Swift.Int, x: Swift.Int, partID: Swift.Int, offset: FritzVision.OffsetType) -> Swift.Double
  public func sum() -> Swift.Double
  @objc deinit
}
@available(iOS 11.0, *)
public class Segments {
  public init(for results: CoreML.MLMultiArray?)
  public subscript(point: FritzVision.HeatmapPoint) -> Swift.Double {
    get
  }
  public subscript(y: Swift.Int, x: Swift.Int) -> Swift.Double {
    get
  }
  public func sum() -> Swift.Double
  @objc deinit
}
public struct Anchor {
  public let yCenter: Swift.Double
  public let xCenter: Swift.Double
  public let height: Swift.Double
  public let width: Swift.Double
  public init(yCenter: Swift.Double, xCenter: Swift.Double, height: Swift.Double, width: Swift.Double)
  public var xMin: Swift.Double {
    get
  }
  public var xMax: Swift.Double {
    get
  }
  public var yMin: Swift.Double {
    get
  }
  public var yMax: Swift.Double {
    get
  }
}
@available(iOS 12.0, *)
public class FritzVisionDrawBoxesCompoundFilter : FritzVision.FritzVisionImageFilter {
  final public let compositionMode: FritzVision.FilterCompositionMode
  final public let model: FritzVision.FritzVisionObjectPredictor
  final public let options: FritzVision.FritzVisionObjectModelOptions
  public init(model: FritzVision.FritzVisionObjectPredictor, options: FritzVision.FritzVisionObjectModelOptions = .init())
  public func process(_ image: FritzVision.FritzVisionImage) -> FritzVision.FritzVisionDrawBoxesCompoundFilter.FritzVisionFilterResult
  @objc deinit
}
@available(iOS 12.0, *)
@objc(FritzVisionLivingRoomSegmentationModelSmall) final public class FritzVisionLivingRoomSegmentationModelSmall : FritzVision.FritzVisionLivingRoomSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionLivingRoomSegmentationModelSmall?, Swift.Error?) -> Swift.Void)
  @objc required public init(model: FritzManagedModel.FritzMLModel)
  @objc required public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc required public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc deinit
}
@objc(FritzVisionHairClass) public class FritzVisionHairClass : ObjectiveC.NSObject {
  @objc public static let none: FritzVision.ModelSegmentationClass
  @objc public static let hair: FritzVision.ModelSegmentationClass
  @objc public static let allClasses: [FritzVision.ModelSegmentationClass]
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionHairSegmentationPredictor) open class FritzVisionHairSegmentationPredictor : FritzVision.FritzVisionSegmentationModel {
  @objc(initWithModel:) convenience public init(model: FritzManagedModel.FritzMLModel)
  @objc(initWithIdentifiedModel:) convenience public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc(initWithModel:managedModel:) convenience public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@available(iOS 11.0, *)
public class DecodePoseWithDisplacements<Skeleton> where Skeleton : FritzVision.SkeletonType {
  public func decodeMultiplePoses(maxPoseDetections: Swift.Int, partThreshold: Swift.Double = 0.5, nmsRadius: Swift.Int = 20) -> [FritzVision.Pose<Skeleton>]
  @objc deinit
}
extension UIImage {
  public static func blend(_ source: UIKit.UIImage, with mask: UIKit.UIImage, blendMode: CoreGraphics.CGBlendMode = .softLight, interpolationQuality: CoreGraphics.CGInterpolationQuality = .none, opacity: CoreGraphics.CGFloat = 1.0) -> UIKit.UIImage?
}
@available(iOS 11.0, *)
extension FritzVisionImage {
  @objc(blendWithMask:blendMode:samplingMethod:opacity:) dynamic public func blend(withMask mask: UIKit.UIImage, blendKernel: CoreImage.CIBlendKernel = .softLight, resizeSamplingMethod samplingMethod: FritzVision.CIImagePipeline.ResizeSamplingMethod = .lanczos, opacity: CoreGraphics.CGFloat = 1.0) -> UIKit.UIImage?
}
@available(iOS 11.0, *)
@objc(FritzVisionPeopleAndPetSegmentationModelAccurate) final public class FritzVisionPeopleAndPetSegmentationModelAccurate : FritzVision.FritzVisionPeopleAndPetSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionPeopleAndPetSegmentationModelAccurate?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@objc(FritzHumanSkeleton) public enum HumanSkeleton : Swift.Int, FritzVision.SkeletonType {
  case nose
  case leftEye
  case rightEye
  case leftEar
  case rightEar
  case leftShoulder
  case rightShoulder
  case leftElbow
  case rightElbow
  case leftWrist
  case rightWrist
  case leftHip
  case rightHip
  case leftKnee
  case rightKnee
  case leftAnkle
  case rightAnkle
  public static let connectedParts: [FritzVision.ConnectedPart<FritzVision.HumanSkeleton>]
  public static let poseChain: [FritzVision.ConnectedPart<FritzVision.HumanSkeleton>]
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
  public typealias AllCases = [FritzVision.HumanSkeleton]
  public static var allCases: [FritzVision.HumanSkeleton] {
    get
  }
}
@available(iOS 11, *)
public typealias HumanPose = FritzVision.Pose<FritzVision.HumanSkeleton>
@objc(FritzVisionDepthModelOptions) final public class FritzVisionDepthModelOptions : ObjectiveC.NSObject, FritzVision.FritzImageOptions {
  public static var defaults: FritzVision.FritzImageOptions
  @objc final public var imageCropAndScaleOption: FritzVision.FritzVisionCropAndScale
  @objc final public var forceCoreMLPrediction: Swift.Bool
  @objc final public var forceVisionPrediction: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
extension AVDepthData : FritzVision.FritzPredictionResult {
}
@available(iOS 11.0, *)
@objc(FritzVisionDepthModel) final public class FritzVisionDepthModel : FritzVision.BasePredictor, FritzVision.DownloadableModel {
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  public static var modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionDepthModel?, Swift.Error?) -> Swift.Void)
  @objc(predict:options:completion:) final public func predict(_ input: FritzVision.FritzVisionImage, options: FritzVision.FritzVisionDepthModelOptions = .init(), completion: (AVFoundation.AVDepthData?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc deinit
  public typealias PredictionInput = FritzVision.FritzVisionImage
  public typealias ModelOptions = FritzVision.FritzVisionDepthModelOptions
  public typealias PredictionResult = AVFoundation.AVDepthData
}
@available(iOS 11.0, *)
@objc(FritzVisionOutdoorSegmentationModelFast) final public class FritzVisionOutdoorSegmentationModelFast : FritzVision.FritzVisionOutdoorSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionOutdoorSegmentationModelFast?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
public struct Heap<T> {
  public init(sort: @escaping (T, T) -> Swift.Bool)
  public init(array: [T], sort: @escaping (T, T) -> Swift.Bool)
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public func peek() -> T?
  mutating public func insert(_ value: T)
  mutating public func insert<S>(_ sequence: S) where T == S.Element, S : Swift.Sequence
  mutating public func replace(index i: Swift.Int, value: T)
  @discardableResult
  mutating public func remove() -> T?
  @discardableResult
  mutating public func remove(at index: Swift.Int) -> T?
}
extension Heap where T : Swift.Equatable {
  public func index(of node: T) -> Swift.Int?
  @discardableResult
  mutating public func remove(node: T) -> T?
}
public struct PriorityQueue<T> {
  public init(sort: @escaping (T, T) -> Swift.Bool)
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: Swift.Int {
    get
  }
  public func peek() -> T?
  mutating public func enqueue(_ element: T)
  mutating public func dequeue() -> T?
  mutating public func changePriority(index i: Swift.Int, value: T)
}
extension PriorityQueue where T : Swift.Equatable {
  public func index(of element: T) -> Swift.Int?
}
@objc(FritzVisionPoseModelOptions) final public class FritzVisionPoseModelOptions : ObjectiveC.NSObject, FritzVision.FritzImageOptions {
  public static let defaults: FritzVision.FritzImageOptions
  @objc final public var imageCropAndScaleOption: FritzVision.FritzVisionCropAndScale
  @objc final public var forceCoreMLPrediction: Swift.Bool
  @objc final public var forceVisionPrediction: Swift.Bool
  @objc final public var minPartThreshold: Swift.Double
  @objc final public var minPoseThreshold: Swift.Double
  @objc final public var nmsRadius: Swift.Int
  final public var smoothingOptions: FritzVision.OneEuroFilterPointable<CoreGraphics.CGPoint>.Options?
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
open class FritzVisionPosePredictor<Skeleton> : FritzVision.BasePredictor where Skeleton : FritzVision.SkeletonType {
  public typealias PredictionInput = FritzVision.FritzVisionImage
  public typealias ModelOptions = FritzVision.FritzVisionPoseModelOptions
  public typealias PredictionResult = FritzVision.FritzVisionPoseResult<Skeleton>
  public var outputStride: Swift.Int
  public var useDisplacements: Swift.Bool
  @objc(initWithModel:) override public init(model: FritzManagedModel.FritzMLModel)
  @objc(initWithIdentifiedModel:) override public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc(initWithModel:managedModel:) override public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  public func predict(_ input: FritzVision.FritzVisionImage, options: FritzVision.FritzVisionPoseModelOptions = .init(), completion: (FritzVision.FritzVisionPoseResult<Skeleton>?, Swift.Error?) -> Swift.Void)
  @objc deinit
}
public protocol FilterOptions {
  init()
}
public protocol PointFilterable {
  associatedtype T : FritzVision.PointType
  associatedtype SmoothingOptionsType : FritzVision.FilterOptions
  init(options: Self.SmoothingOptionsType)
  func filter(_ point: Self.T) -> Self.T
}
@available(iOS 11.0, *)
public class FritzVisionVideo {
  final public let filters: [FritzVision.FritzVisionImageFilter]
  final public let player: AVFoundation.AVPlayer
  public var frameRateScale: Swift.Float
  public var loop: Swift.Bool
  public var duration: Foundation.TimeInterval {
    get
  }
  public init(player: AVFoundation.AVPlayer, applyingFilters filters: [FritzVision.FritzVisionImageFilter] = [])
  convenience public init(player: AVFoundation.AVPlayer, withFilter filter: FritzVision.FritzVisionImageFilter)
  convenience public init(url: Foundation.URL, applyingFilters filters: [FritzVision.FritzVisionImageFilter] = [])
  convenience public init(url: Foundation.URL, withFilter filter: FritzVision.FritzVisionImageFilter)
  convenience public init(path: Swift.String, applyingFilters filters: [FritzVision.FritzVisionImageFilter] = [])
  convenience public init(path: Swift.String, withFilter filter: FritzVision.FritzVisionImageFilter)
  public func stitch(with asset: AVFoundation.AVAsset) throws
  @objc deinit
}
@available(iOS 11.0, *)
extension FritzVisionVideo {
  public typealias ExportCompletionHandler = (Swift.Result<Foundation.URL, FritzVision.FritzVisionVideoError>) -> Swift.Void
  @discardableResult
  public func export(to url: Foundation.URL, as fileType: AVFoundation.AVFileType, with preset: Swift.String = AVAssetExportPresetMediumQuality, onExportComplete: @escaping FritzVision.FritzVisionVideo.ExportCompletionHandler) -> AVFoundation.AVAssetExportSession?
}
@available(iOS 11.0, *)
extension FritzVisionVideo {
  public typealias FrameExtractionCompletionHandler = (Swift.Result<FritzVision.FritzVisionImage, FritzVision.FritzVisionVideoError>) -> Swift.Void
  public func frame(at time: Foundation.TimeInterval, processed: Swift.Bool = true) -> FritzVision.FritzVisionImage?
  public func frames(at times: [Foundation.TimeInterval], processed: Swift.Bool = true, onExtractionComplete: @escaping FritzVision.FritzVisionVideo.FrameExtractionCompletionHandler)
}
public enum FritzVisionVideoError : Swift.Error {
  case invalidVideo
  case invalidUrl
  case invalidExportSession
  case invalidPrediction
  case incompleteExport
  case incompleteExtraction
  case unauthorizedExport
  public func message() -> Swift.String
  public static func == (a: FritzVision.FritzVisionVideoError, b: FritzVision.FritzVisionVideoError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@available(iOS 11.0, *)
extension Pose where Skeleton == FritzVision.HumanSkeleton {
  public func getHipCenter() -> CoreGraphics.CGPoint?
  public func translate() -> [CoreGraphics.CGPoint]?
  public func translateKeypoint() -> [FritzVision.Keypoint<Skeleton>]?
  public func getInputKeypoints(translate: Swift.Bool = true) -> [FritzVision.Keypoint<Skeleton>]?
}
@available(iOS 11.0, *)
extension AVAsynchronousCIImageFilteringRequest {
  public var fritzImage: FritzVision.FritzVisionImage {
    get
  }
}
@available(iOS 11.0, *)
public class FritzVisionPoseResult<Skeleton> : FritzVision.FritzPredictionResult where Skeleton : FritzVision.SkeletonType {
  @objc final public let image: FritzVision.FritzVisionImage
  @objc final public let options: FritzVision.FritzVisionPoseModelOptions
  @objc deinit
}
@available(iOS 11.0, *)
extension FritzVisionPoseResult {
  public func poses(limit: Swift.Int = 5) -> [FritzVision.Pose<Skeleton>]
  public func pose() -> FritzVision.Pose<Skeleton>?
}
@objc(FritzVisionPeopleAndPetSegmentationMediumClass) public class FritzVisionPeopleAndPetClass : ObjectiveC.NSObject {
  @objc public static let none: FritzVision.ModelSegmentationClass
  @objc public static let petOrPerson: FritzVision.ModelSegmentationClass
  @objc public static let allClasses: [FritzVision.ModelSegmentationClass]
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionPeopleAndPetSegmentationMediumModel) public class FritzVisionPeopleAndPetSegmentationPredictor : FritzVision.FritzVisionSegmentationModel {
  @objc(initWithModel:) convenience public init(model: FritzManagedModel.FritzMLModel)
  @objc(initWithIdentifiedModel:) convenience public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc(initWithModel:managedModel:) convenience public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@available(iOS 11.0, *)
public class FritzVisionCutOutPeopleOverlayFilter : FritzVision.FritzVisionSegmentationFilter {
  final public let compositionMode: FritzVision.FilterCompositionMode
  final public let model: FritzVision.FritzVisionSegmentationModel
  final public let options: FritzVision.FritzVisionSegmentationMaskOptions
  public init(model: FritzVision.FritzVisionPeopleSegmentationPredictor, options: FritzVision.FritzVisionSegmentationMaskOptions = .init())
  public func process(_ image: FritzVision.FritzVisionImage) -> FritzVision.FritzVisionCutOutPeopleOverlayFilter.FritzVisionFilterResult
  @objc deinit
}
@available(iOS 11.0, *)
public class Pose3D<Skeleton> where Skeleton : FritzVision.SkeletonType {
  final public let keypoints: [FritzVision.Keypoint3D<Skeleton>]
  final public let score: Swift.Double
  final public let bounds: CoreGraphics.CGSize
  required public init(keypoints: [FritzVision.Keypoint3D<Skeleton>], score: Swift.Double, bounds: CoreGraphics.CGSize)
  public func isEqual(_ object: Any?) -> Swift.Bool
  @objc deinit
}
@available(iOS 11.0, *)
public func == <Skeleton>(lhs: FritzVision.Pose3D<Skeleton>, rhs: FritzVision.Pose3D<Skeleton>) -> Swift.Bool where Skeleton : FritzVision.SkeletonType
@available(iOS 11.0, *)
public protocol FritzVisionImageFilter {
  typealias FritzVisionFilterResult = Swift.Result<FritzVision.FritzVisionImage, Swift.Error>
  var compositionMode: FritzVision.FilterCompositionMode { get }
  func process(_ image: FritzVision.FritzVisionImage) -> Self.FritzVisionFilterResult
}
public enum FilterCompositionMode {
  case compoundWithPreviousOutput
  case overlayOnOriginalImage
  public static func == (a: FritzVision.FilterCompositionMode, b: FritzVision.FilterCompositionMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@available(iOS 11.0, *)
extension CIImagePipeline {
  public func compound(_ filter: FritzVision.FritzVisionImageFilter) throws
  public func overlay(_ filter: FritzVision.FritzVisionImageFilter, using base: CoreImage.CIImage) throws
}
public protocol PoseType : AnyObject {
  associatedtype Skeleton : FritzVision.SkeletonType
  associatedtype Keypoint : FritzVision.KeypointType
  init(keypoints: [Self.Keypoint], score: Swift.Double, bounds: CoreGraphics.CGSize)
  var keypoints: [Self.Keypoint] { get }
  var score: Swift.Double { get }
  var bounds: CoreGraphics.CGSize { get }
  func getPosition<Point>(of part: Self.Skeleton) -> Point? where Point : FritzVision.PointType
}
extension PoseType {
  public func getPosition<Point>(of part: Self.Skeleton) -> Point? where Point : FritzVision.PointType
}
@available(iOS 12.0, *)
@objc(FritzVisionPetSegmentationModelSmall) final public class FritzVisionPetSegmentationModelSmall : FritzVision.FritzVisionPetSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionPetSegmentationModelSmall?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@objc @available(iOS 11.0, *)
public class FritzVisionSegmentationMaskOptions : ObjectiveC.NSObject {
  public var clippingScoresAbove: Swift.Double
  public var zeroingScoresBelow: Swift.Double
  public var maxAlpha: Swift.UInt8
  public var maskColor: UIKit.UIColor
  public var blurRadius: CoreGraphics.CGFloat
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
extension FritzVisionSegmentationResult {
  @objc(buildMultiClassMaskWithMinAcceptedScore:maxAlpha:resize:blurRadius:) dynamic public func buildMultiClassMask(withMinimumAcceptedScore minScore: Swift.Double = 0.0, maxAlpha: Swift.UInt8 = 255, resize: Swift.Bool = true, blurRadius: CoreGraphics.CGFloat = 0) -> UIKit.UIImage?
  @objc(buildSingleClassMask:clippingScoresAbove:zeroingScoresBelow:maxAlpha:resize:color:blurRadius:) dynamic public func buildSingleClassMask(forClass segmentClass: FritzVision.ModelSegmentationClass, clippingScoresAbove clippingThreshold: Swift.Double = 0.5, zeroingScoresBelow zeroingThreshold: Swift.Double = 0.5, maxAlpha: Swift.UInt8 = 255, resize: Swift.Bool = true, color: UIKit.UIColor? = nil, blurRadius: CoreGraphics.CGFloat = 0) -> UIKit.UIImage?
  @objc(buildSingleClassMask:options:resize:) dynamic public func buildSingleClassMask(forClass segmentClass: FritzVision.ModelSegmentationClass, options: FritzVision.FritzVisionSegmentationMaskOptions, resize: Swift.Bool = true) -> UIKit.UIImage?
}
@available(iOS 11.0, *)
public protocol FritzVisionSegmentationFilter : FritzVision.FritzVisionImageFilter {
  var model: FritzVision.FritzVisionSegmentationModel { get }
}
@available(iOS 12.0, *)
@objc(FritzVisionSkySegmentationModelSmall) final public class FritzVisionSkySegmentationModelSmall : FritzVision.FritzVisionSkySegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionSkySegmentationModelSmall?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@available(iOS 11.0, *)
public class FritzVisionStylizeImageCompoundFilter : FritzVision.FritzVisionImageFilter {
  final public let compositionMode: FritzVision.FilterCompositionMode
  final public let model: FritzVision.FritzVisionStylePredictor
  final public let options: FritzVision.FritzVisionStyleModelOptions
  public init(model: FritzVision.FritzVisionStylePredictor, options: FritzVision.FritzVisionStyleModelOptions = .init())
  public func process(_ image: FritzVision.FritzVisionImage) -> FritzVision.FritzVisionStylizeImageCompoundFilter.FritzVisionFilterResult
  @objc deinit
}
@objc(FritzVisionCropAndScale) public enum FritzVisionCropAndScale : Swift.Int {
  case centerCrop = 1
  case scaleFill = 2
  case scaleFit = 3
  public var visionOption: Vision.VNImageCropAndScaleOption {
    get
  }
  public static func getCenterCropRect(forImageToScaleSize size: CoreGraphics.CGSize) -> CoreGraphics.CGRect
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@available(OSX 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
@objc(FritzVisionImage) public class FritzVisionImage : ObjectiveC.NSObject {
  @objc public static let sharedContext: CoreImage.CIContext
  final public let imageBuffer: CoreVideo.CVPixelBuffer?
  final public let sampleBuffer: CoreMedia.CMSampleBuffer?
  final public let image: UIKit.UIImage?
  public var metadata: FritzVision.FritzVisionImageMetadata?
  @objc(initWithBuffer:) public init(buffer: CoreMedia.CMSampleBuffer)
  @objc(initWithImageBuffer:) public init(imageBuffer: CoreVideo.CVPixelBuffer)
  @objc(initWithCIImage:) convenience public init(ciImage: CoreImage.CIImage)
  @objc(initWithImage:) public init(image: UIKit.UIImage)
  @objc(initWithImage:orientation:) public init(image: UIKit.UIImage, orientation: ImageIO.CGImagePropertyOrientation)
  @objc(initWithImageBuffer:orientation:) public init(imageBuffer: CoreVideo.CVPixelBuffer, orientation: ImageIO.CGImagePropertyOrientation)
  @objc(initWithSampleBuffer:connection:) public init(sampleBuffer: CoreMedia.CMSampleBuffer, connection: AVFoundation.AVCaptureConnection)
  public func buildImageRequestHandler() -> Vision.VNImageRequestHandler?
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
extension FritzVisionImage {
  @objc dynamic public var size: CoreGraphics.CGSize {
    @objc get
  }
  public var originalSize: CoreGraphics.CGSize {
    get
  }
}
@available(iOS 11.0, *)
extension FritzVisionImage {
  public var ciImage: CoreImage.CIImage? {
    get
  }
  @objc(toImage) dynamic public func toImage() -> UIKit.UIImage?
  @objc(toPixelBuffer) dynamic public func toPixelBuffer() -> CoreVideo.CVPixelBuffer?
}
@available(iOS 11.0, *)
extension FritzVisionImage {
  public func prepare(size: CoreGraphics.CGSize, scaleCropOption: FritzVision.FritzVisionCropAndScale = .scaleFit) -> CoreVideo.CVPixelBuffer?
  @available(*, deprecated, renamed: "rotated()")
  @objc(rotate) dynamic public func rotate() -> CoreVideo.CVPixelBuffer?
  @objc(rotated) dynamic public func rotated() -> UIKit.UIImage?
  @objc(resizedToSize:) dynamic public func resized(to size: CoreGraphics.CGSize) -> UIKit.UIImage?
}
public enum FritzVisionImageError : Swift.Error {
  case invalidCIImage
  case invalidUIImage
  case invalidCVPixelBuffer
  public func message() -> Swift.String
  public static func == (a: FritzVision.FritzVisionImageError, b: FritzVision.FritzVisionImageError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@available(iOS 11.0, *)
extension FritzVisionImage {
  public func resized(withMaxDimensionLessThan length: CoreGraphics.CGFloat) -> FritzVision.FritzVisionImage?
}
@available(iOS 11.0, *)
@objc(FritzVisionPetSegmentationModelAccurate) final public class FritzVisionPetSegmentationModelAccurate : FritzVision.FritzVisionPetSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionPetSegmentationModelAccurate?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@available(iOS 12.0, *)
@objc(FritzVisionObjectModelFast) final public class FritzVisionObjectModelFast : FritzVision.FritzVisionObjectPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionObjectModelFast?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc override public init(identifiedModel: FritzManagedModel.SwiftIdentifiedModel, classNames: [Swift.String])
  @objc deinit
}
@available(iOS 11.0, *)
public class FritzVisionMaskPeopleOverlayFilter : FritzVision.FritzVisionSegmentationFilter {
  final public let compositionMode: FritzVision.FilterCompositionMode
  final public let model: FritzVision.FritzVisionSegmentationModel
  final public let options: FritzVision.FritzVisionSegmentationMaskOptions
  public init(model: FritzVision.FritzVisionPeopleSegmentationPredictor, options: FritzVision.FritzVisionSegmentationMaskOptions = .init())
  public func process(_ image: FritzVision.FritzVisionImage) -> FritzVision.FritzVisionMaskPeopleOverlayFilter.FritzVisionFilterResult
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionObject) public class FritzVisionObject : ObjectiveC.NSObject, FritzVision.FritzPredictionResult {
  @objc final public let detectedLabel: FritzVision.FritzVisionLabel
  @objc final public let boundingBox: FritzVision.BoundingBox
  @objc public var label: Swift.String {
    @objc get
  }
  @objc public var confidence: Swift.Double {
    @objc get
  }
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc(initWithLabel:boundingBox:) public init(label: FritzVision.FritzVisionLabel, boundingBox: FritzVision.BoundingBox)
  @objc override dynamic public init()
  @objc deinit
}
@objc(FritzVisionLabelModelOptions) final public class FritzVisionLabelModelOptions : ObjectiveC.NSObject, FritzVision.FritzImageOptions {
  public static var defaults: FritzVision.FritzImageOptions
  @objc final public var threshold: Swift.Double
  @objc final public var forceCoreMLPrediction: Swift.Bool
  @objc final public var forceVisionPrediction: Swift.Bool
  @objc final public var numResults: Swift.Int
  @objc final public var imageCropAndScaleOption: FritzVision.FritzVisionCropAndScale
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum FritzVisionLabelError : Swift.Int, Swift.Error {
  case noVisionModel
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
  public static var _nsErrorDomain: Swift.String {
    get
  }
}
@objc @available(iOS 11.0, *)
open class FritzVisionLabelPredictor : FritzVision.BasePredictor {
  public typealias PredictionInput = FritzVision.FritzVisionImage
  public typealias ModelOptions = FritzVision.FritzVisionLabelModelOptions
  public typealias PredictionResult = [FritzVision.FritzVisionLabel]
  @objc(predict:options:completion:) public func predict(_ input: FritzVision.FritzVisionImage, options: FritzVision.FritzVisionLabelModelOptions = .init(), completion: ([FritzVision.FritzVisionLabel]?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc deinit
}
public protocol FritzPredictionResult {
}
@available(iOS 11.0, *)
extension Array : FritzVision.FritzPredictionResult where Element : FritzVision.FritzPredictionResult {
}
extension CVBuffer : FritzVision.FritzPredictionResult {
}
@available(iOS 11.0, *)
extension Pose {
  public func applying(_ t: CoreGraphics.CGAffineTransform) -> FritzVision.Pose<Skeleton>
  public func rotateKeypointsToOriginalImage(image: FritzVision.FritzVisionImage) -> FritzVision.Pose<Skeleton>
}
@available(iOS 11.0, *)
@objc(FritzVisionHairSegmentationModelFast) final public class FritzVisionHairSegmentationModelFast : FritzVision.FritzVisionHairSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionHairSegmentationModelFast?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionSkySegmentationModelFast) final public class FritzVisionSkySegmentationModelFast : FritzVision.FritzVisionSkySegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionSkySegmentationModelFast?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionPeopleSegmentationModelFast) final public class FritzVisionPeopleSegmentationModelFast : FritzVision.FritzVisionPeopleSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionPeopleSegmentationModelFast?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
public enum PoseLiftingDebugKey : Swift.String, Swift.RawRepresentable {
  case pose2DOutput
  case pose2DTranslated
  case poseLiftingInput
  case poseLiftingRawOutput
  case poseLiftingDenormalizedOutput
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@objc(FritzVisionLivingRoomClass) public class FritzVisionLivingRoomClass : ObjectiveC.NSObject {
  @objc public static let none: FritzVision.ModelSegmentationClass
  @objc public static let chair: FritzVision.ModelSegmentationClass
  @objc public static let wall: FritzVision.ModelSegmentationClass
  @objc public static let coffeeTable: FritzVision.ModelSegmentationClass
  @objc public static let ceiling: FritzVision.ModelSegmentationClass
  @objc public static let floor: FritzVision.ModelSegmentationClass
  @objc public static let bed: FritzVision.ModelSegmentationClass
  @objc public static let lamp: FritzVision.ModelSegmentationClass
  @objc public static let sofa: FritzVision.ModelSegmentationClass
  @objc public static let windowpane: FritzVision.ModelSegmentationClass
  @objc public static let pillow: FritzVision.ModelSegmentationClass
  @objc public static let allClasses: [FritzVision.ModelSegmentationClass]
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionLivingRoomSegmentationPredictor) public class FritzVisionLivingRoomSegmentationPredictor : FritzVision.FritzVisionSegmentationModel {
  @objc(initWithModel:) required public init(model: FritzManagedModel.FritzMLModel)
  @objc(initWithIdentifiedModel:) required public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc(initWithModel:managedModel:) required public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
public protocol FritzPredictorOptionType {
  init()
}
public protocol FritzImageOptions : FritzVision.FritzPredictorOptionType {
  static var defaults: FritzVision.FritzImageOptions { get }
  var imageCropAndScaleOption: FritzVision.FritzVisionCropAndScale { get }
  var forceCoreMLPrediction: Swift.Bool { get }
  var forceVisionPrediction: Swift.Bool { get }
}
@available(iOS 11.0, *)
extension Pose : FritzVision.FritzPredictionInput {
}
@objc @objcMembers final public class PoseLiftingPredictorOptions : ObjectiveC.NSObject, FritzVision.FritzPredictorOptionType {
  @objc public static let defaults: FritzVision.PoseLiftingPredictorOptions
  @objc final public var useCPUOnly: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
extension Pose3D : FritzVision.FritzPredictionResult {
}
@objc @available(iOS 11.0, *)
final public class FritzVisionPoseLiftingModel : FritzVision.BasePredictor {
  @objc override public init(model: FritzManagedModel.FritzMLModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc deinit
  public typealias PredictionInput = FritzVision.Pose<FritzVision.HumanSkeleton>
  public typealias ModelOptions = FritzVision.PoseLiftingPredictorOptions
  public typealias PredictionResult = FritzVision.Pose3D<FritzVision.HumanSkeleton>
}
@available(iOS 11.0, *)
extension FritzVisionPoseLiftingModel {
  final public func predict(_ input: FritzVision.Pose<FritzVision.HumanSkeleton>, options: FritzVision.PoseLiftingPredictorOptions = .init(), completion: (FritzVision.Pose3D<FritzVision.HumanSkeleton>?, Swift.Error?) -> Swift.Void)
}
@available(iOS 12.0, *)
@objc(FritzVisionHairSegmentationModelSmall) final public class FritzVisionHairSegmentationModelSmall : FritzVision.FritzVisionHairSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionHairSegmentationModelSmall?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionHairSegmentationModelAccurate) final public class FritzVisionHairSegmentationModelAccurate : FritzVision.FritzVisionHairSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionHairSegmentationModelAccurate?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@objc @available(iOS 11.0, *)
open class BasePredictor : ObjectiveC.NSObject, FritzVision.FritzManagedModelType {
  final public let model: FritzManagedModel.FritzMLModel
  @objc final public let managedModel: FritzManagedModel.FritzManagedModel
  @objc(initWithModel:) public init(model: FritzManagedModel.FritzMLModel)
  @objc(initWithModel:managedModel:) public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc(initWithIdentifiedModel:) public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc public var metadata: FritzManagedModel.ModelMetadata? {
    @objc get
  }
  @objc public var tags: [Swift.String]? {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
public class FritzVisionDrawSkeletonCompoundFilter : FritzVision.FritzVisionImageFilter {
  final public let compositionMode: FritzVision.FilterCompositionMode
  final public let model: FritzVision.FritzVisionHumanPosePredictor
  final public let options: FritzVision.FritzVisionPoseModelOptions
  public init(model: FritzVision.FritzVisionHumanPosePredictor, options: FritzVision.FritzVisionPoseModelOptions = .init())
  public func process(_ image: FritzVision.FritzVisionImage) -> FritzVision.FritzVisionDrawSkeletonCompoundFilter.FritzVisionFilterResult
  @objc deinit
}
@available(iOS 11, *)
extension FritzVisionImage {
  public func masked(with depthData: AVFoundation.AVDepthData, focusingAt depth: CoreGraphics.CGFloat, focalWidth width: CoreGraphics.CGFloat = 1, resizeSamplingMethod samplingMethod: FritzVision.CIImagePipeline.ResizeSamplingMethod = .lanczos) -> UIKit.UIImage?
  public func masked(with depthData: AVFoundation.AVDepthData, pixelsCloserThan depth: CoreGraphics.CGFloat, resizeSamplingMethod samplingMethod: FritzVision.CIImagePipeline.ResizeSamplingMethod = .lanczos) -> UIKit.UIImage?
  public func masked(with depthData: AVFoundation.AVDepthData, pixelsFartherThan depth: CoreGraphics.CGFloat, resizeSamplingMethod samplingMethod: FritzVision.CIImagePipeline.ResizeSamplingMethod = .lanczos) -> UIKit.UIImage?
  public func blurred(with depthData: AVFoundation.AVDepthData, focusingAt depth: CoreGraphics.CGFloat, focalWidth width: CoreGraphics.CGFloat = 1, blurRadius: CoreGraphics.CGFloat = 10, resizeSamplingMethod samplingMethod: FritzVision.CIImagePipeline.ResizeSamplingMethod = .lanczos) -> UIKit.UIImage?
  public func blurred(with depthData: AVFoundation.AVDepthData, pixelsFartherThan depth: CoreGraphics.CGFloat, resizeSamplingMethod samplingMethod: FritzVision.CIImagePipeline.ResizeSamplingMethod = .lanczos, blurRadius: CoreGraphics.CGFloat = 10.0) -> UIKit.UIImage?
  public func blurred(with depthData: AVFoundation.AVDepthData, pixelsCloserThan depth: CoreGraphics.CGFloat, resizeSamplingMethod samplingMethod: FritzVision.CIImagePipeline.ResizeSamplingMethod = .lanczos, blurRadius: CoreGraphics.CGFloat = 10.0) -> UIKit.UIImage?
}
@available(iOS 12.0, *)
@objc(FritzVisionOutdoorSegmentationModelSmall) final public class FritzVisionOutdoorSegmentationModelSmall : FritzVision.FritzVisionOutdoorSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionOutdoorSegmentationModelSmall?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@available(iOS 11.0, *)
public class PoseSmoother<Filter, Skeleton> where Filter : FritzVision.PointFilterable, Skeleton : FritzVision.SkeletonType, Filter.T == CoreGraphics.CGPoint {
  public init(options: Filter.SmoothingOptionsType = Filter.SmoothingOptionsType())
  public func smoothe(_ pose: FritzVision.Pose<Skeleton>) -> FritzVision.Pose<Skeleton>
  @objc deinit
}
@available(iOS 11.0, *)
public class Pose3DSmoother<Filter, Skeleton> where Filter : FritzVision.PointFilterable, Skeleton : FritzVision.SkeletonType, Filter.T == FritzVision.Point3D {
  public init(options: Filter.SmoothingOptionsType)
  public func smoothe(_ pose: FritzVision.Pose3D<Skeleton>) -> FritzVision.Pose3D<Skeleton>
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionPeopleSegmentationModelAccurate) final public class FritzVisionPeopleSegmentationModelAccurate : FritzVision.FritzVisionPeopleSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionPeopleSegmentationModelAccurate?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@available(iOS 11.0, *)
extension FritzVisionImage : FritzManagedModel.Base64StringEncodable {
  public func encode() throws -> Swift.String
  public var encodedFormat: FritzManagedModel.EncodedFormat {
    get
  }
}
@available(iOS 11.0, *)
@objc(FritzVisionLivingRoomSegmentationModelAccurate) final public class FritzVisionLivingRoomSegmentationModelAccurate : FritzVision.FritzVisionLivingRoomSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionLivingRoomSegmentationModelAccurate?, Swift.Error?) -> Swift.Void)
  @objc required public init(model: FritzManagedModel.FritzMLModel)
  @objc required public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc required public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc deinit
}
@objc @objcMembers final public class Point3D : ObjectiveC.NSObject, FritzVision.PointType {
  @objc final public let x: CoreGraphics.CGFloat
  @objc final public let y: CoreGraphics.CGFloat
  @objc final public let z: CoreGraphics.CGFloat
  @objc public init(x: CoreGraphics.CGFloat, y: CoreGraphics.CGFloat, z: CoreGraphics.CGFloat)
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc final public func toArray() -> [Swift.Double]
  @objc override dynamic public init()
  @objc deinit
}
extension Point3D {
  public static func - (lhs: FritzVision.Point3D, rhs: FritzVision.Point3D) -> FritzVision.Point3D
  public static func + (lhs: FritzVision.Point3D, rhs: FritzVision.Point3D) -> FritzVision.Point3D
  public static func / (lhs: FritzVision.Point3D, rhs: CoreGraphics.CGFloat) -> FritzVision.Point3D
  public static func / (lhs: FritzVision.Point3D, rhs: Swift.Double) -> FritzVision.Point3D
  public static func / (lhs: FritzVision.Point3D, rhs: FritzVision.Point3D) -> FritzVision.Point3D
  public static func * (lhs: FritzVision.Point3D, rhs: FritzVision.Point3D) -> FritzVision.Point3D
}
public func == (lhs: FritzVision.Point3D, rhs: FritzVision.Point3D) -> Swift.Bool
@objc(FritzVisionPetClass) public class FritzVisionPetClass : ObjectiveC.NSObject {
  @objc public static let none: FritzVision.ModelSegmentationClass
  @objc public static let pet: FritzVision.ModelSegmentationClass
  @objc public static let allClasses: [FritzVision.ModelSegmentationClass]
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionPetSegmentationPredictor) public class FritzVisionPetSegmentationPredictor : FritzVision.FritzVisionSegmentationModel {
  @objc(initWithModel:) convenience public init(model: FritzManagedModel.FritzMLModel)
  @objc(initWithIdentifiedModel:) convenience public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc(initWithModel:managedModel:) convenience public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@objc(BoundingBox) public class BoundingBox : ObjectiveC.NSObject {
  final public let yMin: Swift.Double
  final public let xMin: Swift.Double
  final public let yMax: Swift.Double
  final public let xMax: Swift.Double
  @objc(initWithYMin:xMin:yMax:xMax:) public init(yMin: Swift.Double, xMin: Swift.Double, yMax: Swift.Double, xMax: Swift.Double)
  public init(fromAnchor anchor: FritzVision.Anchor)
  public init(from rect: CoreGraphics.CGRect)
  @objc(imgHeight:imgWidth:) public func toCGRect(imgHeight: Swift.Double, imgWidth: Swift.Double) -> CoreGraphics.CGRect
  @objc(imgHeight:imgWidth:xOffset:yOffset:) public func toCGRect(imgHeight: Swift.Double, imgWidth: Swift.Double, xOffset: Swift.Double, yOffset: Swift.Double) -> CoreGraphics.CGRect
  public func scaledBy(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGRect
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
extension CocoImageAnnotation {
  public init<Skeleton>(pose: FritzVision.Pose<Skeleton>) where Skeleton : FritzVision.SkeletonType
}
@available(iOS 11.0, *)
extension Pose : FritzManagedModel.AnnotationRepresentable {
  public func annotations(for input: FritzVision.FritzVisionImage) -> [FritzManagedModel.CocoImageAnnotation]
  public typealias Source = FritzVision.FritzVisionImage
  public typealias Annotation = FritzManagedModel.CocoImageAnnotation
}
@available(iOS 11.0, *)
extension FritzVisionPosePredictor : FritzVision.PredictionImageRecordable {
  public typealias AnnotationRepresentation = [FritzVision.Pose<Skeleton>]
}
@objc(FritzVisionOutdoorClass) public class FritzVisionOutdoorClass : ObjectiveC.NSObject {
  @objc public static let none: FritzVision.ModelSegmentationClass
  @objc public static let building: FritzVision.ModelSegmentationClass
  @objc public static let sky: FritzVision.ModelSegmentationClass
  @objc public static let tree: FritzVision.ModelSegmentationClass
  @objc public static let sidewalk: FritzVision.ModelSegmentationClass
  @objc public static let ground: FritzVision.ModelSegmentationClass
  @objc public static let car: FritzVision.ModelSegmentationClass
  @objc public static let water: FritzVision.ModelSegmentationClass
  @objc public static let house: FritzVision.ModelSegmentationClass
  @objc public static let fence: FritzVision.ModelSegmentationClass
  @objc public static let sign: FritzVision.ModelSegmentationClass
  @objc public static let skyscraper: FritzVision.ModelSegmentationClass
  @objc public static let bridge: FritzVision.ModelSegmentationClass
  @objc public static let river: FritzVision.ModelSegmentationClass
  @objc public static let bus: FritzVision.ModelSegmentationClass
  @objc public static let truck: FritzVision.ModelSegmentationClass
  @objc public static let van: FritzVision.ModelSegmentationClass
  @objc public static let motorbike: FritzVision.ModelSegmentationClass
  @objc public static let bicycle: FritzVision.ModelSegmentationClass
  @objc public static let trafficLight: FritzVision.ModelSegmentationClass
  @objc public static let person: FritzVision.ModelSegmentationClass
  @objc public static let allClasses: [FritzVision.ModelSegmentationClass]
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionOutdoorSegmentationPredictor) public class FritzVisionOutdoorSegmentationPredictor : FritzVision.FritzVisionSegmentationModel {
  @objc(initWithModel:) convenience public init(model: FritzManagedModel.FritzMLModel)
  @objc(initWithIdentifiedModel:) convenience public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc(initWithModel:managedModel:) convenience public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
extension CGPoint {
  public init(point: FritzVision.SmoothingPoint)
  public func buildAccelPoint(count: Swift.Int) -> FritzVision.SmoothingPoint
}
extension CGPoint : FritzVision.ArrayInitializable {
  public init(with array: [CoreGraphics.CGFloat])
}
public class PoseSmoothingOptions {
  public init(frequency: Swift.Double = 1.0, minCutoff: Swift.Double = 1.0, beta: Swift.Double = 0.0, derivateCutoff: Swift.Double = 1.0)
  @objc deinit
}
public class Keypoint<Skeleton> : ObjectiveC.NSObject, FritzVision.KeypointType where Skeleton : FritzVision.SkeletonType {
  final public let index: Swift.Int
  final public let position: CoreGraphics.CGPoint
  final public let score: Swift.Double
  final public let part: Skeleton
  required public init(index: Swift.Int, position: CoreGraphics.CGPoint, score: Swift.Double, part: Skeleton)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  public func fromPosition(_ position: CoreGraphics.CGPoint) -> Self
  public func to3D() -> FritzVision.Keypoint3D<Skeleton>
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  public func normalized(by size: CoreGraphics.CGSize) -> FritzVision.Keypoint<Skeleton>
  @objc override dynamic public init()
  public typealias Point = CoreGraphics.CGPoint
  @objc deinit
}
public func == <Skeleton>(lhs: FritzVision.Keypoint<Skeleton>, rhs: FritzVision.Keypoint<Skeleton>) -> Swift.Bool where Skeleton : FritzVision.SkeletonType
@objc(FritzVisionSkyClass) public class FritzVisionSkyClass : ObjectiveC.NSObject {
  @objc public static let none: FritzVision.ModelSegmentationClass
  @objc public static let sky: FritzVision.ModelSegmentationClass
  @objc public static let allClasses: [FritzVision.ModelSegmentationClass]
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionSkySegmentationPredictor) public class FritzVisionSkySegmentationPredictor : FritzVision.FritzVisionSegmentationModel {
  @objc(initWithModel:) convenience public init(model: FritzManagedModel.FritzMLModel)
  @objc(initWithIdentifiedModel:) convenience public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc(initWithModel:managedModel:) convenience public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
extension CGPoint : FritzVision.PointType {
  public func toArray() -> [Swift.Double]
  public static func - (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
  public static func + (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
  public static func / (lhs: CoreGraphics.CGPoint, by: Swift.Double) -> CoreGraphics.CGPoint
  public static func / (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
  public static func * (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
  public static func * (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGSize) -> CoreGraphics.CGPoint
  public static func / (lhs: CoreGraphics.CGPoint, rhs: CoreGraphics.CGSize) -> CoreGraphics.CGPoint
}
@available(iOS 11.0, *)
public protocol FritzMLModelInitializable {
  init(model: FritzManagedModel.FritzMLModel) throws
  init(model: FritzManagedModel.SwiftIdentifiedModel) throws
  init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel) throws
}
@available(iOS 11.0, *)
public protocol DownloadableModel : FritzVision.FritzMLModelInitializable {
  static var modelConfig: FritzManagedModel.FritzModelConfiguration { get }
  static var managedModel: FritzManagedModel.FritzManagedModel { get }
  static var wifiRequiredForModelDownload: Swift.Bool { get set }
  static func fetchModel(completionHandler: @escaping (Self?, Swift.Error?) -> Swift.Void)
}
@available(iOS 11.0, *)
extension DownloadableModel {
  public static var _wifiRequiredForModelDownload: Swift.Bool {
    get
    set
  }
  public static func _fetchModel(completionHandler: @escaping (Self?, Swift.Error?) -> Swift.Void)
}
@objc @available(iOS 11.0, *)
open class FritzVideoView : UIKit.UIView {
  public var fritzVideo: FritzVision.FritzVisionVideo? {
    get
    set
  }
  public var isPlaying: Swift.Bool {
    get
  }
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc dynamic public init()
  public init(source: FritzVision.FritzVisionVideo)
  public func play()
  public func pause()
  public func stop()
  public func seek(to time: Foundation.TimeInterval)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public protocol FritzPredictionInput : AnyObject {
}
@available(iOS 11.0, *)
extension FritzVisionImage : FritzVision.FritzPredictionInput {
}
public protocol SmoothingPointable : FritzVision.PointType {
  init(_ point: FritzVision.SmoothingPoint)
  func buildSmoothingPoint(count: Swift.Int) -> FritzVision.SmoothingPoint
}
extension Point3D : FritzVision.SmoothingPointable {
  convenience public init(_ point: FritzVision.SmoothingPoint)
  final public func buildSmoothingPoint(count: Swift.Int) -> FritzVision.SmoothingPoint
}
extension CGPoint : FritzVision.SmoothingPointable {
  public init(_ point: FritzVision.SmoothingPoint)
  public func buildSmoothingPoint(count: Swift.Int) -> FritzVision.SmoothingPoint
}
@objcMembers public class OneEuroFilterPointable<Point> : ObjectiveC.NSObject, FritzVision.PointFilterable where Point : FritzVision.ArrayInitializable {
  final public class Options : FritzVision.FilterOptions {
    final public let frequency: Swift.Double
    final public let minCutoff: Swift.Double
    final public let beta: Swift.Double
    final public let derivateCutoff: Swift.Double
    public init(frequency: Swift.Double = 1.0, minCutoff: Swift.Double = 1.0, beta: Swift.Double = 0.0, derivateCutoff: Swift.Double = 0.0)
    required public init()
    @objc deinit
  }
  required public init(options: FritzVision.OneEuroFilterPointable<Point>.Options = .init())
  public func filter(_ point: Point) -> Point
  @objc override dynamic public init()
  public typealias T = Point
  public typealias SmoothingOptionsType = FritzVision.OneEuroFilterPointable<Point>.Options
  @objc deinit
}
public class OneEuroPointFilter : FritzVision.OneEuroFilterPointable<CoreGraphics.CGPoint> {
  public static let low: FritzVision.OneEuroFilterPointable<CoreGraphics.CGPoint>.Options
  required public init(options: FritzVision.OneEuroFilterPointable<CoreGraphics.CGPoint>.Options = super)
  @objc deinit
}
@objc(FritzVisionObjectModelOptions) final public class FritzVisionObjectModelOptions : ObjectiveC.NSObject, FritzVision.FritzImageOptions {
  @objc final public var threshold: Swift.Double
  @objc final public var iouThreshold: Swift.Double
  @objc final public var numResults: Swift.Int
  @objc final public var imageCropAndScaleOption: FritzVision.FritzVisionCropAndScale
  @objc final public let forceCoreMLPrediction: Swift.Bool
  @objc final public var forceVisionPrediction: Swift.Bool
  public static var defaults: FritzVision.FritzImageOptions
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 12.0, *)
@objc(FritzVisionObjectPredictor) public class FritzVisionObjectPredictor : FritzVision.BasePredictor {
  @objc(initWithModel:) override public init(model: FritzManagedModel.FritzMLModel)
  @objc(initWithModel:managedModel:) override public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc(initWithIdentifiedModel:) override public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc(initWithIdentifiedModel:processedLabels:) public init(identifiedModel: FritzManagedModel.SwiftIdentifiedModel, classNames: [Swift.String])
  @objc(predict:options:completion:) public func predict(_ input: FritzVision.FritzVisionImage, options: FritzVision.FritzVisionObjectModelOptions = .init(), completion: ([FritzVision.FritzVisionObject]?, Swift.Error?) -> Swift.Void)
  public typealias PredictionInput = FritzVision.FritzVisionImage
  public typealias ModelOptions = FritzVision.FritzVisionObjectModelOptions
  public typealias PredictionResult = Swift.Array<FritzVision.FritzVisionObject>
  @objc deinit
}
@objc(FritzVisionSegmentationModelOptions) final public class FritzVisionSegmentationModelOptions : ObjectiveC.NSObject, FritzVision.FritzImageOptions {
  public static var defaults: FritzVision.FritzImageOptions
  @objc final public var imageCropAndScaleOption: FritzVision.FritzVisionCropAndScale
  @objc final public var forceCoreMLPrediction: Swift.Bool
  @objc final public var forceVisionPrediction: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@objc(ModelSegmentationClass) public class ModelSegmentationClass : ObjectiveC.NSObject {
  @objc final public let index: Swift.Int
  @objc final public let label: Swift.String
  final public let color: FritzVision.rgbaValue
  public init(label: Swift.String, index: Swift.Int, color: FritzVision.rgbaValue)
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionSegmentationModel) open class FritzVisionSegmentationModel : FritzVision.BasePredictor {
  @objc final public let name: Swift.String
  @objc final public let classes: [FritzVision.ModelSegmentationClass]
  @objc(initWithModel:name:classes:) public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc(initWithModel:name:classes:managedModel:) public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc(initWithIdentifiedModel:name:classes:) public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc(predict:options:completion:) public func predict(_ input: FritzVision.FritzVisionImage, options: FritzVision.FritzVisionSegmentationModelOptions = .init(), completion: (FritzVision.FritzVisionSegmentationResult?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc deinit
  public typealias PredictionInput = FritzVision.FritzVisionImage
  public typealias ModelOptions = FritzVision.FritzVisionSegmentationModelOptions
  public typealias PredictionResult = FritzVision.FritzVisionSegmentationResult
}
public typealias rgbaValue = (r: Swift.UInt8, g: Swift.UInt8, b: Swift.UInt8, a: Swift.UInt8)
@available(iOS 11.0, *)
public protocol PredictionRecordable : FritzVision.FritzPredictable where Self.PredictionInput : FritzManagedModel.Base64StringEncodable {
  associatedtype AnnotationRepresentation : FritzManagedModel.AnnotationRepresentable where Self.PredictionInput == Self.AnnotationRepresentation.Source
  var model: FritzManagedModel.FritzMLModel { get }
  func record(_ input: Self.PredictionInput, predicted predictedRepresentation: Self.AnnotationRepresentation, modified modifiedRepresentation: Self.AnnotationRepresentation?) -> FritzCore.SessionEvent?
}
@available(iOS 11.0, *)
extension PredictionRecordable {
  @discardableResult
  public func record(_ input: Self.PredictionInput, predicted predictedRepresentation: Self.AnnotationRepresentation, modified modifiedRepresentation: Self.AnnotationRepresentation? = nil) -> FritzCore.SessionEvent?
}
@available(iOS 11.0, *)
public protocol PredictionImageRecordable : FritzVision.PredictionRecordable where Self.PredictionInput == FritzVision.FritzVisionImage {
  associatedtype PredictionInput = FritzVision.FritzVisionImage
}
@available(iOS 11.0, *)
extension PredictionImageRecordable {
  @discardableResult
  public func record(_ input: FritzVision.FritzVisionImage, predicted predictedRepresentation: Self.AnnotationRepresentation, modified modifiedRepresentation: Self.AnnotationRepresentation? = nil) -> FritzCore.SessionEvent?
}
@available(iOS 11.0, *)
@objc(FritzVisionSkySegmentationModelAccurate) final public class FritzVisionSkySegmentationModelAccurate : FritzVision.FritzVisionSkySegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionSkySegmentationModelAccurate?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@objc(FritzVisionPeopleClass) public class FritzVisionPeopleClass : ObjectiveC.NSObject {
  @objc public static let none: FritzVision.ModelSegmentationClass
  @objc public static let person: FritzVision.ModelSegmentationClass
  @objc public static let allClasses: [FritzVision.ModelSegmentationClass]
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionPeopleSegmentationPredictor) open class FritzVisionPeopleSegmentationPredictor : FritzVision.FritzVisionSegmentationModel {
  @objc(initWithModel:) convenience public init(model: FritzManagedModel.FritzMLModel)
  @objc(initWithIdentifiedModel:) convenience public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc(initWithModel:managedModel:) convenience public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionHumanPoseModelFast) @_objcRuntimeName(FritzVisionHumanPoseModelFast) final public class FritzVisionHumanPoseModelFast : FritzVision.FritzVisionHumanPosePredictor, FritzVision.DownloadableModel {
  @objc public static var modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionHumanPoseModelFast?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel)
  @objc override public init(model: FritzManagedModel.FritzMLModel, managedModel: FritzManagedModel.FritzManagedModel)
  @objc deinit
}
@available(iOS 11.0, *)
@objc(FritzVisionOutdoorSegmentationModelAccurate) final public class FritzVisionOutdoorSegmentationModelAccurate : FritzVision.FritzVisionOutdoorSegmentationPredictor, FritzVision.DownloadableModel {
  @objc public static let modelConfig: FritzManagedModel.FritzModelConfiguration
  @objc public static var managedModel: FritzManagedModel.FritzManagedModel {
    @objc get
  }
  @objc public static var wifiRequiredForModelDownload: Swift.Bool
  @objc(fetchModelWithCompletionHandler:) public static func fetchModel(completionHandler: @escaping (FritzVision.FritzVisionOutdoorSegmentationModelAccurate?, Swift.Error?) -> Swift.Void)
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc override public init(model: FritzManagedModel.FritzMLModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass], managedModel: FritzManagedModel.FritzManagedModel)
  @objc override public init(model: FritzManagedModel.SwiftIdentifiedModel, name: Swift.String, classes: [FritzVision.ModelSegmentationClass])
  @objc deinit
}
@objc @available(iOS 11.0, *)
@objcMembers public class CIImagePipeline : ObjectiveC.NSObject {
  @objc(ResizeSamplingMethod) public enum ResizeSamplingMethod : Swift.Int {
    case lanczos
    case bicubic
    case affine
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public var image: CoreImage.CIImage
  @objc public var resizeSamplingMethod: FritzVision.CIImagePipeline.ResizeSamplingMethod
  @objc public init(_ image: CoreImage.CIImage, context: CoreImage.CIContext? = nil)
  @objc public func render() -> CoreVideo.CVPixelBuffer?
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 11.0, *)
extension CIImagePipeline {
  @objc dynamic public func centerCrop()
  @objc dynamic public func orient(_ orientation: ImageIO.CGImagePropertyOrientation)
  public func resize(_ size: CoreGraphics.CGSize, usingSamplingMethod samplingMethod: FritzVision.CIImagePipeline.ResizeSamplingMethod? = nil)
  @objc dynamic public func blend(with mask: UIKit.UIImage, blendKernel kernel: CoreImage.CIBlendKernel = CIBlendKernel.softLight, opacity: CoreGraphics.CGFloat = 1.0)
  @objc dynamic public func blur(blurRadius: CoreGraphics.CGFloat)
}
@objc public enum FritzVisionError : Swift.Int, Swift.Error {
  case invalidImageBuffer
  case errorProcessingImage
  case imageNotEncodable
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOS 11.0, *)
extension FritzVision.FritzImageOrientation : Swift.Equatable {}
@available(iOS 11.0, *)
extension FritzVision.FritzImageOrientation : Swift.Hashable {}
@available(iOS 11.0, *)
extension FritzVision.FritzImageOrientation : Swift.RawRepresentable {}
extension FritzVision.SegmentationRegion : Swift.Equatable {}
extension FritzVision.SegmentationRegion : Swift.Hashable {}
extension FritzVision.SegmentationRegion : Swift.RawRepresentable {}
@available(iOS 11.0, *)
extension FritzVision.FritzVisionStylePredictor : FritzVision.FritzVisionImagePredictable {}
@available(iOS 11.0, *)
extension FritzVision.FritzVisionStylePredictor : FritzVision.FritzPredictable {}
extension FritzVision.OffsetType : Swift.Equatable {}
extension FritzVision.OffsetType : Swift.Hashable {}
extension FritzVision.HumanSkeleton : Swift.Hashable {}
@available(iOS 11.0, *)
extension FritzVision.FritzVisionDepthModel : FritzVision.FritzVisionImagePredictable {}
@available(iOS 11.0, *)
extension FritzVision.FritzVisionDepthModel : FritzVision.FritzPredictable {}
@available(iOS 11.0, *)
extension FritzVision.FritzVisionPosePredictor : FritzVision.FritzVisionImagePredictable {}
extension FritzVision.FritzVisionVideoError : Swift.Equatable {}
extension FritzVision.FritzVisionVideoError : Swift.Hashable {}
extension FritzVision.FilterCompositionMode : Swift.Equatable {}
extension FritzVision.FilterCompositionMode : Swift.Hashable {}
extension FritzVision.FritzVisionCropAndScale : Swift.Hashable {}
extension FritzVision.FritzVisionCropAndScale : Swift.RawRepresentable {}
extension FritzVision.FritzVisionImageError : Swift.Equatable {}
extension FritzVision.FritzVisionImageError : Swift.Hashable {}
extension FritzVision.FritzVisionLabelError : Swift.Equatable {}
extension FritzVision.FritzVisionLabelError : Swift.Hashable {}
extension FritzVision.FritzVisionLabelError : Swift.RawRepresentable {}
@available(iOS 11.0, *)
extension FritzVision.FritzVisionLabelPredictor : FritzVision.FritzVisionImagePredictable {}
@available(iOS 11.0, *)
extension FritzVision.FritzVisionLabelPredictor : FritzVision.FritzPredictable {}
extension FritzVision.PoseLiftingDebugKey : Swift.Equatable {}
extension FritzVision.PoseLiftingDebugKey : Swift.Hashable {}
@available(iOS 11.0, *)
extension FritzVision.FritzVisionPoseLiftingModel : FritzVision.FritzPredictable {}
@available(iOS 12.0, *)
extension FritzVision.FritzVisionObjectPredictor : FritzVision.FritzPredictable {}
@available(iOS 12.0, *)
extension FritzVision.FritzVisionObjectPredictor : FritzVision.FritzVisionImagePredictable {}
@available(iOS 11.0, *)
extension FritzVision.FritzVisionSegmentationModel : FritzVision.FritzVisionImagePredictable {}
@available(iOS 11.0, *)
extension FritzVision.FritzVisionSegmentationModel : FritzVision.FritzPredictable {}
@available(iOS 11.0, *)
extension FritzVision.CIImagePipeline.ResizeSamplingMethod : Swift.Equatable {}
@available(iOS 11.0, *)
extension FritzVision.CIImagePipeline.ResizeSamplingMethod : Swift.Hashable {}
@available(iOS 11.0, *)
extension FritzVision.CIImagePipeline.ResizeSamplingMethod : Swift.RawRepresentable {}
